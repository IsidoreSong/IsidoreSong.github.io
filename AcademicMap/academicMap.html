<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Research Map</title>
    
    <!-- KaTeX for LaTeX formula rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>

    <style>
        :root {
            --bg-color: #f9f9f9;
            --panel-bg-color: #ffffff;
            --border-color: #e0e0e0;
            --text-color: #333;
            --text-secondary-color: #666;
            --primary-color: #007bff;
            --highlight-color: #ffeb3b;
            --predecessor-color: #f44336;
            --successor-color: #4caf50;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
        }
        .main-container { display: flex; height: 100vh; width: 100vw; }
        .left-panel { flex-grow: 1; display: flex; flex-direction: column; padding: 15px; box-sizing: border-box; }
        header { text-align: center; flex-shrink: 0; }
        .controls { display: flex; justify-content: center; align-items: center; gap: 15px; padding: 10px 0; flex-wrap: wrap; flex-shrink: 0; }
        .filter-btn { padding: 8px 16px; border: 1px solid var(--border-color); border-radius: 20px; background-color: var(--panel-bg-color); cursor: pointer; transition: all 0.2s ease; }
        .filter-btn[data-filter="all"].active, .filter-btn[data-filter="all"]:hover { background-color: var(--primary-color); color: white; border-color: var(--primary-color); }
        .filter-btn:not([data-filter="all"]):hover { filter: brightness(1.1); }
        .filter-btn:not([data-filter="all"]).active { box-shadow: 0 0 0 2px white, 0 0 0 4px var(--primary-color); }
        .slider-container { display: flex; align-items: center; gap: 8px; font-size: 14px; }
        #graph-container { flex-grow: 1; border: 1px solid var(--border-color); background-color: var(--panel-bg-color); box-shadow: 0 2px 8px rgba(0,0,0,0.05); border-radius: 8px; position: relative; }
        .right-panel { width: 420px; flex-shrink: 0; background-color: var(--panel-bg-color); border-left: 1px solid var(--border-color); padding: 25px; box-sizing: border-box; overflow-y: auto; box-shadow: -4px 0 15px rgba(0,0,0,0.05); }
        .details-placeholder { text-align: center; color: var(--text-secondary-color); margin-top: 40%; }
        #details-content h2 { margin-top: 0; color: var(--primary-color); line-height: 1.3; }
        #details-content h4 { color: #333; border-bottom: 2px solid #eee; padding-bottom: 5px; margin-top: 20px; }
        #formula-display { margin-top: 10px; font-size: 1.1em; }
        
        #formula-display .katex-html {
            display: none !important;
        }
        
        #formula-display .katex-mathml {
            display: block !important;
        }
        
        svg { width: 100%; height: 100%; }
        .year-band { fill: #f8f9fa; }
        .year-band:nth-child(odd) { fill: #eff2f5; }
        .year-label { fill: #adb5bd; font-size: 14px; font-weight: 500; text-anchor: end; }
        .node circle { stroke: #fff; stroke-width: 2.5px; cursor: pointer; transition: all 0.2s ease-out; }
        .node:hover circle { transform: scale(1.2); filter: drop-shadow(0px 0px 5px rgba(0,0,0,0.3)); }
        .node.selected circle { stroke: var(--primary-color); stroke-width: 4px; }
        .node text { font-size: 10px; pointer-events: none; fill: #444; text-anchor: middle; }
        .link { stroke: #aaa; stroke-opacity: 0.8; fill: none; transition: all 0.2s ease-out; }
        .arrow-head { fill: #888; transition: fill 0.2s ease-out; }

        .node.highlighted circle { stroke: var(--highlight-color); stroke-width: 3px; }
        .node.predecessor circle { stroke: var(--predecessor-color); stroke-width: 3px; }
        .node.successor circle { stroke: var(--successor-color); stroke-width: 3px; }
        .link.highlighted, .link.predecessor, .link.successor { stroke-opacity: 1; stroke-width: 2.5px; }
        .link.predecessor { stroke: var(--predecessor-color); }
        .link.predecessor .arrow-head { fill: var(--predecessor-color); }
        .link.successor { stroke: var(--successor-color); }
        .link.successor .arrow-head { fill: var(--successor-color); }
        .faded { opacity: 0.4; }
        .link.faded { opacity: 1; stroke-opacity: 0.6; }
        #tooltip { position: absolute; background-color: rgba(0, 0, 0, 0.8); color: white; padding: 8px 12px; border-radius: 5px; font-size: 12px; pointer-events: none; opacity: 0; transition: opacity 0.2s; z-index: 10; }
        .loading-message { text-align: center; color: var(--text-secondary-color); margin-top: 40%; }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="left-panel">
            <header>
                <h1>Evolution Network of Face Recognition Papers</h1>
            </header>
            <div class="controls" id="controls-container">
                <button class="filter-btn active" data-filter="all">All</button>
                <!-- Category buttons will be generated here -->
                <div class="slider-container">
                    <label for="radius-slider">Node Size:</label>
                    <input type="range" id="radius-slider" min="5" max="25" value="12">
                </div>
            </div>
            <div id="graph-container">
                <div id="tooltip"></div>
                <div class="loading-message" id="loading">Loading data...</div>
            </div>
        </div>
        <div class="right-panel" id="details-panel">
            <div id="details-content">
                <div class="details-placeholder">
                    <h3>Welcome</h3>
                    <p>Click on a node in the graph<br>to view details here</p>
                </div>
            </div>
        </div>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>

    <script>
    // Test data (fallback)
    const testPapersData = [
        // 2020
        {id: "p1", title: "DeepFace: Closing the Gap to Human-Level Performance", authors: "Taigman et al.", year: 2020, method: "DeepFace", category: "Classification", 
         core_idea: "Using deep convolutional neural networks for face recognition", formula: "L = -\\sum_{i} y_i \\log(\\hat{y}_i)", contribution: "First to achieve near-human level recognition accuracy", influences: []},
        {id: "p2", title: "FaceNet: A Unified Embedding", authors: "Schroff et al.", year: 2020, method: "FaceNet", category: "Metric", 
         core_idea: "Learning face embeddings through triplet loss", formula: "L = \\max(0, ||f(a)-f(p)||^2 - ||f(a)-f(n)||^2 + \\alpha)", contribution: "Proposed an end-to-end face embedding learning method", influences: ["p1"]},
        {id: "p3", title: "VGGFace: Deep Face Recognition", authors: "Parkhi et al.", year: 2020, method: "VGGFace", category: "Classification", 
         core_idea: "Using VGG network architecture for face recognition", formula: "L_{CE} = -\\log\\frac{e^{W_y^T f + b_y}}{\\sum_j e^{W_j^T f + b_j}}", contribution: "Demonstrated the effectiveness of deep networks in face recognition", influences: ["p1"]},
        
        // 2021
        {id: "p4", title: "SphereFace: Deep Hypersphere Embedding", authors: "Liu et al.", year: 2021, method: "SphereFace", category: "Metric", 
         core_idea: "Learning discriminative features on hypersphere", formula: "L = -\\frac{1}{N}\\sum_i \\log\\frac{e^{||W_{y_i}||||f_i||\\cos(m\\theta_{y_i})}}{e^{||W_{y_i}||||f_i||\\cos(m\\theta_{y_i})} + \\sum_{j\\neq y_i} e^{||W_j||||f_i||\\cos\\theta_j}}", 
         contribution: "Introduced angular margin to enhance inter-class separability", influences: ["p2", "p3"]},
        {id: "p5", title: "CosFace: Large Margin Cosine Loss", authors: "Wang et al.", year: 2021, method: "CosFace", category: "Metric", 
         core_idea: "Using cosine margin to enhance feature discriminability", formula: "L = -\\frac{1}{N}\\sum_i \\log\\frac{e^{s(\\cos\\theta_{y_i} - m)}}{e^{s(\\cos\\theta_{y_i} - m)} + \\sum_{j\\neq y_i} e^{s\\cos\\theta_j}}", 
         contribution: "Simplified the implementation of angular margin", influences: ["p4"]},
        {id: "p6", title: "ArcFace: Additive Angular Margin Loss", authors: "Deng et al.", year: 2021, method: "ArcFace", category: "Metric", 
         core_idea: "Adding additive margin in angular space", formula: "L = -\\frac{1}{N}\\sum_i \\log\\frac{e^{s\\cos(\\theta_{y_i} + m)}}{e^{s\\cos(\\theta_{y_i} + m)} + \\sum_{j\\neq y_i} e^{s\\cos\\theta_j}}", 
         contribution: "Provided clearer geometric interpretation and better performance", influences: ["p4", "p5"]},
        
        // 2022
        {id: "p7", title: "AdaFace: Quality Adaptive Margin", authors: "Kim et al.", year: 2022, method: "AdaFace", category: "Metric", 
         core_idea: "Adaptively adjusting margins based on image quality", formula: "L = -\\frac{1}{N}\\sum_i \\log\\frac{e^{s\\cos(\\theta_{y_i} + m_i)}}{e^{s\\cos(\\theta_{y_i} + m_i)} + \\sum_{j\\neq y_i} e^{s\\cos\\theta_j}}", 
         contribution: "Improved robustness to images of varying quality", influences: ["p6"]},
        {id: "p8", title: "MagFace: A Universal Representation", authors: "Meng et al.", year: 2022, method: "MagFace", category: "Metric", 
         core_idea: "Learning both magnitude and angular features simultaneously", formula: "L = -\\frac{1}{N}\\sum_i \\log\\frac{e^{s||f_i||\\cos(\\theta_{y_i} + m)}}{e^{s||f_i||\\cos(\\theta_{y_i} + m)} + \\sum_{j\\neq y_i} e^{s||f_i||\\cos\\theta_j}}", 
         contribution: "Unified multiple dimensions of features", influences: ["p6"]},
        {id: "p9", title: "SimCLR for Face: Self-Supervised Learning", authors: "Chen et al.", year: 2022, method: "SimCLR-Face", category: "Self-Supervised", 
         core_idea: "Using contrastive learning for self-supervised pretraining", formula: "L = -\\log\\frac{e^{sim(z_i, z_j)/\\tau}}{\\sum_{k=1}^{2N} \\mathbb{1}_{k\\neq i} e^{sim(z_i, z_k)/\\tau}}", 
         contribution: "Reduced dependence on labeled data", influences: ["p6"]},
        
        // 2023
        {id: "p10", title: "TransFace: Calibrating Transformer", authors: "Dan et al.", year: 2023, method: "TransFace", category: "Analysis", 
         core_idea: "Analyzing and calibrating Transformer applications in face recognition", formula: "\\text{Attention}(Q, K, V) = \\text{softmax}(\\frac{QK^T}{\\sqrt{d_k}})V", 
         contribution: "Revealed advantages and limitations of Transformer", influences: ["p7", "p8"]},
        {id: "p11", title: "SFace: Sigmoid-Constrained Loss", authors: "Zhong et al.", year: 2023, method: "SFace", category: "Metric", 
         core_idea: "Constraining loss function with Sigmoid function", formula: "L = -\\frac{1}{N}\\sum_i \\log\\frac{e^{s\\cdot\\sigma(\\cos(\\theta_{y_i} + m))}}{e^{s\\cdot\\sigma(\\cos(\\theta_{y_i} + m))} + \\sum_{j\\neq y_i} e^{s\\cdot\\sigma(\\cos\\theta_j)}}", 
         contribution: "Improved training stability", influences: ["p7"]},
        {id: "p12", title: "MoCo-Face: Momentum Contrast", authors: "He et al.", year: 2023, method: "MoCo-Face", category: "Self-Supervised", 
         core_idea: "Using momentum contrast for self-supervised learning", formula: "L = -\\log\\frac{e^{q\\cdot k_+/\\tau}}{e^{q\\cdot k_+/\\tau} + \\sum_{k_-} e^{q\\cdot k_-/\\tau}}", 
         contribution: "Provided a better self-supervised learning framework", influences: ["p9"]},
        
        // 2024
        {id: "p13", title: "UniFace: Unified Framework", authors: "Zhang et al.", year: 2024, method: "UniFace", category: "Analysis", 
         core_idea: "Unifying multiple face recognition paradigms", formula: "L_{total} = \\lambda_1 L_{cls} + \\lambda_2 L_{metric} + \\lambda_3 L_{ssl}", 
         contribution: "Provided a unified theoretical framework", influences: ["p10", "p11", "p12"]},
        {id: "p14", title: "PromptFace: Vision-Language Model", authors: "Li et al.", year: 2024, method: "PromptFace", category: "Classification", 
         core_idea: "Using vision-language models for face recognition", formula: "\\text{similarity}(I, T) = \\frac{f_v(I)^T f_t(T)}{||f_v(I)|| \\cdot ||f_t(T)||}", 
         contribution: "Introduced a multimodal learning paradigm", influences: ["p13"]},
        {id: "p15", title: "FaceMAE: Masked Autoencoder", authors: "Zhou et al.", year: 2024, method: "FaceMAE", category: "Self-Supervised", 
         core_idea: "Using masked autoencoder for pretraining", formula: "L = ||x - \\hat{x}||^2", 
         contribution: "Demonstrated the potential of generative pretraining", influences: ["p12", "p13"]}
    ];

    // Try to load external data, use test data if failed
    let papersData = null;

    // Check if external papersData exists
    function loadData() {
        return new Promise((resolve) => {
            // Check if papersData has already been loaded by external script
            if (typeof window.papersData !== 'undefined') {
                papersData = window.papersData;
                console.log('Detected external papersData, using external data');
                resolve();
                return;
            }

            // Try to load external script
            const script = document.createElement('script');
            script.src = 'papersData.js';
            script.onload = () => {
                if (typeof window.papersData !== 'undefined') {
                    papersData = window.papersData;
                    console.log('Successfully loaded external data file');
                } else {
                    papersData = testPapersData;
                    console.log('External data file does not define papersData, using test data');
                }
                resolve();
            };
            script.onerror = () => {
                papersData = testPapersData;
                console.log('Failed to load external data file, using test data');
                resolve();
            };
            document.head.appendChild(script);
            
            // Set timeout to prevent infinite waiting
            setTimeout(() => {
                if (!papersData) {
                    papersData = testPapersData;
                    console.log('Loading timeout, using test data');
                    resolve();
                }
            }, 2000);
        });
    }
    </script>

    <script>
    document.addEventListener("DOMContentLoaded", async function() {
        // Load data first
        await loadData();
        
        const container = document.getElementById('graph-container');
        const loadingMsg = document.getElementById('loading');
        const tooltip = d3.select("#tooltip");
        const detailsContent = document.getElementById('details-content');
        const radiusSlider = document.getElementById('radius-slider');

        // Hide loading message
        if (loadingMsg) loadingMsg.style.display = 'none';

        const margin = {top: 40, right: 20, bottom: 40, left: 70};
        let width, height;
        let nodeRadius = +radiusSlider.value;
        let activeFilter = 'all';
        let selectedNode = null;
        let yScale = d3.scaleBand();
        
        // Dynamically generate category filter buttons
        function generateCategoryButtons() {
            const controlsContainer = document.getElementById('controls-container');
            const allCategories = [...new Set(papersData.map(paper => paper.category))];
            
            // Add event listener for "All" button
            const allButton = document.querySelector('[data-filter="all"]');
            if (allButton) {
                allButton.addEventListener('click', function() {
                    document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    activeFilter = 'all';
                    updateGraph();
                });
            }
            
            allCategories.forEach(category => {
                const button = document.createElement('button');
                button.className = 'filter-btn';
                button.setAttribute('data-filter', category);
                button.textContent = category;
                const color = categoryColors[category];
                button.style.backgroundColor = color;
                button.style.color = 'white';
                button.style.borderColor = color;
                button.addEventListener('click', function() {
                    document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    activeFilter = this.getAttribute('data-filter');
                    updateGraph();
                });
                controlsContainer.insertBefore(button, controlsContainer.lastElementChild);
            });
        }
        
        function getContainerDimensions() {
            const rect = container.getBoundingClientRect();
            width = rect.width;
            height = rect.height;
        }
        
        getContainerDimensions();

        const svg = d3.select(container).append("svg")
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("viewBox", [0, 0, width, height])
            .style("display", "block");

        // Automatically generate category color mapping
        function generateCategoryColors(categories) {
            const colors = {};
            const colorPalette = [
                '#28a745', '#dc3545', '#ffc107', '#17a2b8', 
                '#6f42c1', '#fd7e14', '#20c997', '#e83e8c',
                '#6610f2', '#007bff', '#d63384', '#343a40'
            ];
            
            categories.forEach((category, index) => {
                colors[category] = colorPalette[index % colorPalette.length];
            });
            
            return colors;
        }
        
        // Extract all unique categories from data
        const allCategories = [...new Set(papersData.map(paper => paper.category))];
        const categoryColors = generateCategoryColors(allCategories);

        // Generate filter buttons
        generateCategoryButtons();

        const simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(d => d.id).distance(120).strength(0.3))
            .force("charge", d3.forceManyBody().strength(-150))
            .force("collide", d3.forceCollide().radius(d => nodeRadius + 20))
            .force("x", d3.forceX(width / 2).strength(0.05))
            .alphaDecay(0.015);
        
        const gridGroup = svg.append("g").attr("class", "grid");
        const linkGroup = svg.append("g").attr("class", "links");
        const nodeGroup = svg.append("g").attr("class", "nodes");
        
        // Define markers for different link types
        const defs = svg.append("defs");
        
        // Default marker
        defs.append("marker")
            .attr("id", "arrowhead")
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 15)
            .attr("refY", 0)
            .attr("markerWidth", 8)
            .attr("markerHeight", 8)
            .attr("orient", "auto")
          .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("class", "arrow-head")
            .style("fill", "#888")
            .style("stroke", "none");
            
        // Predecessor marker (incoming links)
        defs.append("marker")
            .attr("id", "arrowhead-predecessor")
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 15)
            .attr("refY", 0)
            .attr("markerWidth", 8)
            .attr("markerHeight", 8)
            .attr("orient", "auto")
          .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .style("fill", "var(--predecessor-color)")
            .style("stroke", "none");
            
        // Successor marker (outgoing links)
        defs.append("marker")
            .attr("id", "arrowhead-successor")
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 15)
            .attr("refY", 0)
            .attr("markerWidth", 8)
            .attr("markerHeight", 8)
            .attr("orient", "auto")
          .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .style("fill", "var(--successor-color)")
            .style("stroke", "none");

        function updateGraph() {
            let filteredPapers = (activeFilter === 'all')
                ? papersData
                : papersData.filter(p => p.category === activeFilter);

            const paperIds = new Set(filteredPapers.map(p => p.id));
            let filteredLinks = [];
            papersData.forEach(paper => {
                if (paper.influences) {
                    paper.influences.forEach(influenceId => {
                        if (paperIds.has(paper.id) && paperIds.has(influenceId)) {
                             filteredLinks.push({ source: influenceId, target: paper.id });
                        }
                    });
                }
            });

            const years = Array.from(new Set(filteredPapers.map(d => d.year))).sort(d3.descending);
            
            const yearCounts = {};
            years.forEach(year => {
                yearCounts[year] = filteredPapers.filter(p => p.year === year).length;
            });
            
            const totalNodes = filteredPapers.length;
            const availableHeight = height - margin.top - margin.bottom;
            const minBandHeight = 120;
            
            const yearHeights = {};
            years.forEach(year => {
                const nodeCount = yearCounts[year];
                const proportionalHeight = (nodeCount / totalNodes) * availableHeight;
                yearHeights[year] = Math.max(minBandHeight, proportionalHeight);
            });
            
            const totalAllocatedHeight = Object.values(yearHeights).reduce((sum, h) => sum + h, 0);
            const heightScaleFactor = totalAllocatedHeight > availableHeight ? 
                                     availableHeight / totalAllocatedHeight : 1;
            
            let currentY = margin.top;
            const yearRanges = {};
            years.forEach(year => {
                const bandHeight = yearHeights[year] * heightScaleFactor;
                yearRanges[year] = { start: currentY, height: bandHeight };
                currentY += bandHeight;
            });
            
            yScale = function(year) {
                return yearRanges[year] ? yearRanges[year].start : margin.top;
            };
            
            yScale.bandwidth = function(year) {
                return yearRanges[year] ? yearRanges[year].height : minBandHeight;
            };
            
            gridGroup.selectAll("*").remove();
            gridGroup.selectAll(".year-band")
                .data(years)
                .enter().append("rect")
                .attr("class", "year-band")
                .attr("x", margin.left)
                .attr("y", d => yScale(d))
                .attr("width", width - margin.left - margin.right)
                .attr("height", d => yScale.bandwidth(d));

            gridGroup.selectAll(".year-label")
                .data(years)
                .enter().append("text")
                .attr("class", "year-label")
                .attr("x", margin.left - 10)
                .attr("y", d => yScale(d) + yScale.bandwidth(d) / 2)
                .attr("dy", "0.32em")
                .text(d => d);

            const nodes = filteredPapers.map((d, i) => {
                const bandY = yScale(d.year);
                const bandHeight = yScale.bandwidth(d.year);
                const nodesInYear = filteredPapers.filter(p => p.year === d.year).length;
                const indexInYear = filteredPapers.filter(p => p.year === d.year).indexOf(d);
                
                // 计算可用宽度
                const availableWidth = width - margin.left - margin.right - nodeRadius * 2;
                
                // Use smarter initialization: evenly distribute within year bands with random offset
                    let initialX;
                    if (nodesInYear === 1) {
                        // Single node placed in the middle
                        initialX = width / 2;
                    } else {
                        // Multiple nodes: even distribution + random offset
                        const spacing = availableWidth / (nodesInYear + 1);
                        const baseX = margin.left + nodeRadius + spacing * (indexInYear + 1);
                        const randomOffset = (Math.random() - 0.5) * spacing * 0.4; // 40% random offset
                        initialX = baseX + randomOffset;
                    }
                    
                    // Add some randomness to Y-axis as well, but keep within year bands
                    const padding = nodeRadius + 10;
                    const availableYRange = bandHeight - padding * 2;
                    const randomY = bandY + padding + Math.random() * availableYRange;
                
                return {
                    ...d,
                    x: d.x || initialX,
                    y: d.y || randomY
                };
            });
            
            const links = filteredLinks;

            const node = nodeGroup.selectAll("g.node")
                .data(nodes, d => d.id)
                .join(
                    enter => {
                        const g = enter.append("g").attr("class", "node");
                        g.append("circle").attr("r", nodeRadius).attr("fill", d => categoryColors[d.category] || '#ccc');
                        g.append("text").text(d => d.method).attr("dy", d => nodeRadius + 12);
                        g.call(drag(simulation));
                        g.on("mouseover", handleMouseOver).on("mouseout", handleMouseOut).on("click", handleClick);
                        return g;
                    },
                    update => update,
                    exit => exit.remove()
                );
            
            const link = linkGroup.selectAll("line.link")
                .data(links, d => `${d.source.id || d.source}-${d.target.id || d.target}`)
                .join("line")
                .attr("class", "link")
                .attr("marker-end", "url(#arrowhead)");

            simulation.nodes(nodes);
            simulation.force("link").links(links);
            
            // Update X-axis force to ensure nodes cluster toward center rather than edges
            simulation.force("x", d3.forceX(width / 2).strength(0.05));
            
            simulation.alpha(1).restart();
            
            simulation.on("tick", () => {
                nodes.forEach(d => {
                    const bandY = yScale(d.year);
                    const bandHeight = yScale.bandwidth(d.year);
                    const padding = nodeRadius + 5;
                    
                    // Limit X-axis range to prevent nodes from going to the edges
                    const minX = margin.left + padding + 20;
                    const maxX = width - margin.right - padding - 20;
                    d.x = Math.max(minX, Math.min(maxX, d.x));
                    
                    // Limit Y-axis within year bands
                    d.y = Math.max(bandY + padding, Math.min(bandY + bandHeight - padding, d.y));
                });
                
                // Handle predecessor-successor relationship nodes - gentler constraints
                links.forEach(link => {
                    const sourceNode = typeof link.source === 'object' ? link.source : nodes.find(n => n.id === link.source);
                    const targetNode = typeof link.target === 'object' ? link.target : nodes.find(n => n.id === link.target);
                    
                    if (sourceNode && targetNode && sourceNode.year === targetNode.year) {
                        const minSpacing = nodeRadius * 2;
                        
                        // Only adjust when nodes are too close
                        if (Math.abs(targetNode.y - sourceNode.y) < minSpacing) {
                            const midY = (sourceNode.y + targetNode.y) / 2;
                            const bandY = yScale(sourceNode.year);
                            const bandHeight = yScale.bandwidth(sourceNode.year);
                            const padding = nodeRadius + 5;
                            
                            // Use gentler adjustment
                            const adjustment = minSpacing / 2;
                            sourceNode.y = Math.max(bandY + padding, Math.min(bandY + bandHeight - padding, midY - adjustment));
                            targetNode.y = Math.max(bandY + padding, Math.min(bandY + bandHeight - padding, midY + adjustment));
                        } else if (targetNode.y < sourceNode.y - nodeRadius) {
                            // Ensure referenced node is above
                            const diff = (targetNode.y - sourceNode.y) * 0.1; // 10% adjustment strength
                            sourceNode.y += diff;
                            targetNode.y -= diff;
                        }
                    }
                });
            
                link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
                node.attr("transform", d => `translate(${d.x},${d.y})`);
            });

            if (selectedNode && !paperIds.has(selectedNode.id)) {
                clearDetails();
            }
        }
        
        function handleMouseOver(event, d) {
            tooltip.style("opacity", 1)
                   .html(`<strong>${d.title}</strong>`)
                   .style("left", (event.pageX + 15) + "px")
                   .style("top", (event.pageY - 10) + "px");
            highlight(d);
        }
        
        function handleMouseOut() {
            tooltip.style("opacity", 0);
            unhighlight();
        }

        function handleClick(event, d) {
            selectedNode = d;
            displayDetails(d);
            nodeGroup.selectAll("g.node").classed("selected", n => n.id === d.id);
            // Instead of unhighlighting, we should highlight the selected node and its connections
            highlight(d);
        }

        function displayDetails(paper) {
            const currentFormula = paper.formula;
            
            detailsContent.innerHTML = `
                <h2>${paper.title}</h2>
                <p><strong>${paper.authors} (${paper.year})</strong></p>
                <p><strong>Method:</strong> ${paper.method}</p>
                <h4>Core Idea</h4><p>${paper.core_idea}</p>
                <h4>Key Formula</h4><div id="formula-display" data-formula="${currentFormula || ''}"></div>
                <h4>Key Contributions</h4><p>${paper.contribution}</p>
            `;
            
            const formulaDiv = document.getElementById('formula-display');
            if (formulaDiv) {
                if (currentFormula && currentFormula !== 'N/A' && currentFormula !== 'Policy-based RL Loss') {
                    try {
                        katex.render(currentFormula, formulaDiv, {
                            displayMode: true,
                            throwOnError: false,
                            strict: 'ignore'
                        });
                        const katexHtml = formulaDiv.querySelector('.katex-html');
                        if (katexHtml) {
                            katexHtml.style.display = 'none';
                        }
                    } catch (e) {
                        formulaDiv.textContent = '公式渲染失败: ' + currentFormula;
                    }
                } else {
                    formulaDiv.textContent = currentFormula || 'N/A';
                }
            }
        }

        function clearDetails() {
            selectedNode = null;
            nodeGroup.selectAll("g.node").classed("selected", false);
            detailsContent.innerHTML = `<div class="details-placeholder"><h3>Welcome</h3><p>Click on a node in the graph<br>to view details here</p></div>`;
        }
        
        function highlight(d) {
            if (!d) return;
            const predecessors = new Set();
            const successors = new Set();
            
            linkGroup.selectAll("line.link").data().forEach(l => {
                const sourceId = l.source.id || l.source;
                const targetId = l.target.id || l.target;
                if (targetId === d.id) predecessors.add(sourceId);
                if (sourceId === d.id) successors.add(targetId);
            });

            nodeGroup.selectAll("g.node")
                .classed("faded", n => n.id !== d.id && !predecessors.has(n.id) && !successors.has(n.id))
                .filter(n => n.id === d.id).classed("highlighted", true)
                .filter(n => predecessors.has(n.id)).classed("predecessor", true)
                .filter(n => successors.has(n.id)).classed("successor", true);
            
            linkGroup.selectAll("line.link")
                .classed("faded", l => {
                    const sourceId = l.source.id || l.source;
                    const targetId = l.target.id || l.target;
                    return sourceId !== d.id && targetId !== d.id;
                })
                .filter(l => {
                    const targetId = l.target.id || l.target;
                    return targetId === d.id;
                }).classed("predecessor", true)
                .attr("marker-end", function(l) {
                    const targetId = l.target.id || l.target;
                    if (targetId === d.id) {
                        return "url(#arrowhead-predecessor)";
                    }
                    return d3.select(this).attr("marker-end");
                })
                .filter(l => {
                    const sourceId = l.source.id || l.source;
                    return sourceId === d.id;
                }).classed("successor", true)
                .attr("marker-end", function(l) {
                    const sourceId = l.source.id || l.source;
                    if (sourceId === d.id) {
                        return "url(#arrowhead-successor)";
                    }
                    return d3.select(this).attr("marker-end");
                });
        }
        
        function unhighlight() {
            nodeGroup.selectAll("g.node").classed("faded highlighted predecessor successor", false);
            linkGroup.selectAll("line.link")
                .classed("faded predecessor successor", false)
                .attr("marker-end", "url(#arrowhead)");
        }

        function updateNodeRadius(radius) {
            nodeRadius = +radius;
            nodeGroup.selectAll("circle").transition().duration(200).attr("r", nodeRadius);
            nodeGroup.selectAll("text").transition().duration(200).attr("dy", nodeRadius + 12);
            svg.select("#arrowhead").attr("refX", nodeRadius + 10);
            simulation.force("collide").radius(nodeRadius + 15);
            simulation.alpha(0.3).restart();
        }
        
        function drag(simulation) {
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            function dragged(event, d) {
                const bandY = yScale(d.year);
                const bandHeight = yScale.bandwidth(d.year);
                const padding = nodeRadius + 5;
                
                d.fx = Math.max(margin.left + padding, Math.min(width - margin.right - padding, event.x));
                d.fy = Math.max(bandY + padding, Math.min(bandY + bandHeight - padding, event.y));
            }
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
        }

        // Button event listeners have been moved to the generateCategoryButtons function

        radiusSlider.addEventListener('input', (e) => updateNodeRadius(e.target.value));

        window.addEventListener('resize', () => {
            getContainerDimensions();
            svg.attr("viewBox", [0, 0, width, height]);
            updateGraph();
        });

        setTimeout(() => {
            getContainerDimensions();
            svg.attr("viewBox", [0, 0, width, height]);
            updateGraph();
            updateNodeRadius(radiusSlider.value);
        }, 100);
    });
    </script>
</body>
</html>